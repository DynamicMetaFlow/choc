// Generated by CoffeeScript 1.6.3
(function() {
  var escodegen, esmorph, esprima, generateReadableExpression, generateReadableStatement, inspect, puts, readableNode, _, _ref;

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  _ = require("underscore");

  generateReadableExpression = function(node, opts) {
    var message, operators;
    if (opts == null) {
      opts = {};
    }
    switch (node.type) {
      case 'AssignmentExpression':
        operators = {
          "=": "'set " + node.left.name + " to ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ")",
          "+=": "'add ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' to " + node.left.name + " and set " + node.left.name + " to ' + " + node.left.name,
          "-=": "'subtract ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' from " + node.left.name + "'",
          "*=": "'multiply " + node.left.name + " by ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") ",
          "/=": "'divide " + node.left.name + " by ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") ",
          "%=": "'divide " + node.left.name + " by ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' and set " + node.left.name + " to the remainder'"
        };
        message = operators[node.operator] || "";
        return "[ { lineNumber: " + node.loc.start.line + ", message: " + message + " }]";
      case 'BinaryExpression':
        operators = {
          "==": "''",
          "!=": "''",
          "===": "''",
          "!==": "''",
          "<": "''",
          "<=": "__choc_first_message(" + (generateReadableExpression(node.left)) + ") + ' <= ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ")",
          ">": "''",
          ">=": "''",
          "<<": "''",
          ">>": "''",
          ">>>": "''",
          "+": "'add ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' to " + node.left.name + " and set " + node.left.name + " to ' + " + node.left.name,
          "-": "''",
          "*": "''",
          "/": "''",
          "%": "''",
          "|": "''",
          "^": "''",
          "in": "''",
          "instanceof": "''",
          "..": "''"
        };
        message = operators[node.operator] || "";
        return "[ { lineNumber: " + node.loc.start.line + ", message: " + message + " } ]";
      case 'Literal':
        return "[ { lineNumber: " + node.loc.start.line + ", message: '" + node.value + "' } ]";
      case 'Identifier':
        return "[ { lineNumber: " + node.loc.start.line + ", message: " + node.name + " } ]";
      default:
        return "[]";
    }
  };

  generateReadableStatement = function(node, opts) {
    var conditional, i, msgs, sentences;
    if (opts == null) {
      opts = {};
    }
    switch (node.type) {
      case 'VariableDeclaration':
        i = 0;
        sentences = _.map(node.declarations, function(dec) {
          var name, prefix;
          name = dec.id.name;
          prefix = i === 0 ? "Create" : " and create";
          i = i + 1;
          return "'" + prefix + " the variable <span class=\"choc-variable\">" + name + "</span> and set it to <span class=\"choc-value\">' + " + name + " + '</span>'";
        });
        msgs = _.map(sentences, function(sentence) {
          var s;
          s = "{ ";
          s += "lineNumber: " + node.loc.start.line + ", ";
          s += "message: " + sentence;
          return s += " }";
        });
        return "[ " + msgs.join(", ") + " ]";
      case 'ExpressionStatement':
        return generateReadableExpression(node.expression);
      case 'WhileStatement':
        puts(inspect(node));
        conditional = opts.hoistedAttributes ? opts.hoistedAttributes[1] : true;
        return "(function (__conditional) { \n if(__conditional) { \n   var startLine = " + node.loc.start.line + ";\n   var endLine   = " + node.loc.end.line + ";\n   var messages = [ { lineNumber: startLine, message: \"Because \" + __choc_first_message(" + (generateReadableExpression(node.test)) + ") } ]\n   for(var i=startLine+1; i<= endLine; i++) {\n     var message = i == startLine+1 ? \"do this\" : \"and this\";\n     messages.push({ lineNumber: i, message: message });\n   }\n   messages.push( { lineNumber: endLine, message: \"... and try again\" } )\n   // do this\n   // and this\n   // ... and try again\n   return messages;\n } else {\n   // Because -> condition with variables expanded e.g. 0 <= 200 is false\n   // ... stop looping\n   var startLine = " + node.loc.start.line + ";\n   var endLine   = " + node.loc.end.line + ";\n   var messages = [ { lineNumber: startLine, message: \"Because \" + __choc_first_message(" + (generateReadableExpression(node.test)) + ") + \" is false\"} ]\n   messages.push( { lineNumber: endLine, message: \"stop looping\" } )\n   return messages;\n }\n})(" + conditional + ")";
      default:
        return "[]";
    }
  };

  readableNode = function(node, opts) {
    if (opts == null) {
      opts = {};
    }
    switch (node.type) {
      case 'VariableDeclaration':
      case 'ExpressionStatement':
      case 'WhileStatement':
        return generateReadableStatement(node, opts);
      case 'AssignmentExpression':
        return generateReadableExpression(node, opts);
      default:
        return "[]";
    }
  };

  exports.readableNode = readableNode;

}).call(this);
