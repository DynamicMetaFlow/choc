// Generated by CoffeeScript 1.6.3
(function() {
  var Choc, Tracer, collectNodes, collectStatements, debug, deep, escodegen, esmorph, esprima, generateAnnotatedSource, generateAnnotatedSourceM, generateVariableDeclaration, hoist, inspect, isStatement, noop, puts, readable, scrub, statementAnnotator, traverse, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  _ = require("underscore");

  readable = require("./readable");

  debug = require("debug")("choc");

  deep = require("deep");

  Choc = {
    VERSION: "0.0.1",
    TRACE_FUNCTION_NAME: "__choc_trace",
    PAUSE_ERROR_NAME: "__choc_pause",
    EXECUTION_FINISHED_ERROR_NAME: "__choc_finished"
  };

  isStatement = function(nodeType) {
    var statements;
    statements = ['BreakStatement', 'ContinueStatement', 'DoWhileStatement', 'DebuggerStatement', 'EmptyStatement', 'ExpressionStatement', 'ForStatement', 'ForInStatement', 'IfStatement', 'LabeledStatement', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'WhileStatement', 'WithStatement', 'VariableDeclaration'];
    return _.contains(statements, nodeType);
  };

  traverse = function(object, visitor, path) {
    var child, key, _results;
    key = void 0;
    child = void 0;
    if (typeof path === "undefined") {
      path = [];
    }
    visitor.call(null, object, path);
    _results = [];
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        child = object[key];
        if (typeof child === "object" && child !== null) {
          _results.push(traverse(child, visitor, [object].concat(path)));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  collectNodes = function(tree, condition) {
    var nodes;
    nodes = [];
    traverse(tree, function(node, path) {
      if (condition(node, path)) {
        puts("condition met");
        puts(inspect(path));
        puts("/condition met");
        return nodes.push({
          node: node,
          path: path
        });
      }
    });
    return nodes;
  };

  collectStatements = function(tree) {
    return collectNodes(tree, function(node, path) {
      return isStatement(node.type);
    });
  };

  statementAnnotator = function(traceName) {
    return function(code) {
      var fragments, i, line, messagesString, node, nodeType, pos, range, signature, statementList, tree;
      tree = esprima.parse(code, {
        range: true,
        loc: true
      });
      statementList = collectStatements(tree);
      fragments = [];
      i = 0;
      while (i < statementList.length) {
        node = statementList[i].node;
        nodeType = node.type;
        line = node.loc.start.line;
        range = node.range;
        pos = node.range[1];
        if (node.hasOwnProperty("body")) {
          pos = node.body.range[0] + 1;
        } else if (node.hasOwnProperty("block")) {
          pos = node.block.range[0] + 1;
        }
        messagesString = readable.readableNode(node);
        signature = "" + traceName + "({ lineNumber: " + line + ", range: [ " + range[0] + ", " + range[1] + " ], type: '" + nodeType + "', messages: " + messagesString + " });";
        fragments.push({
          index: pos,
          text: " " + signature
        });
        i += 1;
      }
      return fragments;
    };
  };

  generateVariableDeclaration = function(varInit) {
    var identifier;
    identifier = "__choc_var_" + Math.floor(Math.random() * 1000000);
    ({
      type: 'VariableDeclaration',
      kind: 'var',
      declarations: [
        {
          type: 'VariableDeclarator',
          id: {
            type: 'Identifier',
            name: identifier
          },
          init: {
            type: 'Literal',
            value: 1
          }
        }
      ]
    });
    return identifier;
  };

  hoist = function(source) {
    var statementList, tree;
    tree = esprima.parse(source);
    puts(inspect(tree, null, 20));
    statementList = collectStatements(tree);
    puts("===");
    puts(inspect(statementList, null, 20));
    return puts(escodegen.generate(tree));
  };

  generateAnnotatedSource = function(source) {
    var modifiers, morphed;
    modifiers = [statementAnnotator(Choc.TRACE_FUNCTION_NAME)];
    morphed = esmorph.modify(source, modifiers);
    return morphed;
  };

  generateAnnotatedSourceM = _.memoize(generateAnnotatedSource);

  Tracer = (function() {
    function Tracer(options) {
      if (options == null) {
        options = {};
      }
      this.trace = __bind(this.trace, this);
      this.frameCount = 0;
      this.onMessages = function() {};
      this.clearTimeline();
    }

    Tracer.prototype.clearTimeline = function() {
      return this.timeline = {
        steps: [],
        stepMap: {},
        maxLines: 0
      };
    };

    Tracer.prototype.trace = function(opts) {
      var _this = this;
      this.frameCount = 0;
      return function(info) {
        var error, _base, _name;
        _this.timeline.steps[_this.frameCount] = {
          lineNumber: info.lineNumber
        };
        (_base = _this.timeline.stepMap)[_name = _this.frameCount] || (_base[_name] = {});
        _this.timeline.stepMap[_this.frameCount][info.lineNumber - 1] = true;
        _this.timeline.maxLines = Math.max(_this.timeline.maxLines, info.lineNumber);
        info.frameNumber = _this.frameCount;
        _this.frameCount = _this.frameCount + 1;
        if (_this.frameCount >= opts.count) {
          _this.onMessages(info.messages);
          error = new Error(Choc.PAUSE_ERROR_NAME);
          error.info = info;
          throw error;
        }
      };
    };

    return Tracer;

  })();

  noop = function() {};

  scrub = function(source, count, opts) {
    var afterAll, afterEach, beforeEach, e, executionTerminated, locals, localsStr, newSource, onFrame, onMessages, onTimeline, tracer, __choc_first_message, __choc_trace;
    onFrame = opts.onFrame || noop;
    beforeEach = opts.beforeEach || noop;
    afterEach = opts.afterEach || noop;
    afterAll = opts.afterAll || noop;
    onTimeline = opts.onTimeline || noop;
    onMessages = opts.onMessages || noop;
    locals = opts.locals || {};
    newSource = generateAnnotatedSourceM(source);
    debug(newSource);
    tracer = new Tracer();
    tracer.onMessages = onMessages;
    tracer.onTimeline = onTimeline;
    executionTerminated = false;
    try {
      beforeEach();
      __choc_trace = tracer.trace({
        count: count
      });
      __choc_first_message = function(messages) {
        var _ref1;
        return ((_ref1 = messages[0]) != null ? _ref1.message : void 0) || "TODO";
      };
      locals.Choc = Choc;
      localsStr = _.map(_.keys(locals), function(name) {
        return "var " + name + " = locals." + name + ";";
      }).join("; ");
      eval(localsStr + "\n" + newSource);
      return executionTerminated = true;
    } catch (_error) {
      e = _error;
      if (e.message === Choc.PAUSE_ERROR_NAME) {
        return onFrame(e.info);
      } else {
        throw e;
      }
    } finally {
      afterEach();
      if (executionTerminated) {
        afterAll({
          frameCount: tracer.frameCount
        });
        onTimeline(tracer.timeline);
      }
    }
  };

  exports.scrub = scrub;

  exports.generateAnnotatedSource = generateAnnotatedSource;

  exports._hoist = hoist;

}).call(this);
