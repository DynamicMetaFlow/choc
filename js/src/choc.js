// Generated by CoffeeScript 1.6.3
(function() {
  var Choc, Tracer, collectStatements, escodegen, esmorph, esprima, generateScrubbedSource, inspect, isStatement, noop, puts, readableNode, scrub, scrubNotify, source, source_todo, todo, tracers, traverse, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  _ = require("underscore");

  Choc = {
    VERSION: "0.0.1",
    TRACE_FUNCTION_NAME: "__choc_trace",
    PAUSE_ERROR_NAME: "__choc_pause",
    EXECUTION_FINISHED_ERROR_NAME: "__choc_finished"
  };

  isStatement = function(thing) {
    var statements;
    statements = ['BreakStatement', 'ContinueStatement', 'DoWhileStatement', 'DebuggerStatement', 'EmptyStatement', 'ExpressionStatement', 'ForStatement', 'ForInStatement', 'IfStatement', 'LabeledStatement', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'WhileStatement', 'WithStatement', 'VariableDeclaration'];
    return _.contains(statements, thing);
  };

  traverse = function(object, visitor, path) {
    var child, key, _results;
    key = void 0;
    child = void 0;
    if (typeof path === "undefined") {
      path = [];
    }
    visitor.call(null, object, path);
    _results = [];
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        child = object[key];
        if (typeof child === "object" && child !== null) {
          _results.push(traverse(child, visitor, [object].concat(path)));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  collectStatements = function(code, tree) {
    var statements;
    statements = [];
    traverse(tree, function(node, path) {
      if (isStatement(node.type)) {
        return statements.push({
          node: node,
          path: path
        });
      }
    });
    return statements;
  };

  readableNode = function(node) {
    var i, msgs, sentences;
    switch (node.type) {
      case 'VariableDeclaration':
        i = 0;
        sentences = _.map(node.declarations, function(dec) {
          var name, prefix;
          name = dec.id.name;
          prefix = i === 0 ? "Create" : " and create";
          i = i + 1;
          return '"' + prefix + ' the variable <span class=\\"choc-variable\\">' + name + '</span> and set it to <span class=\\"choc-value\\">" + ' + name + ' + "</span>"';
        });
        msgs = _.map(sentences, function(sentence) {
          var s;
          s = "{ ";
          s += "lineNumber: " + node.loc.start.line + ", ";
          s += "message: " + sentence;
          return s += " }";
        });
        return "[ " + msgs.join(", ") + " ]";
      default:
        return "[]";
    }
  };

  tracers = {
    postStatement: function(traceName) {
      return function(code) {
        var fragments, i, line, messagesString, node, nodeType, pos, range, signature, statementList, tree;
        tree = esprima.parse(code, {
          range: true,
          loc: true
        });
        statementList = collectStatements(code, tree);
        fragments = [];
        i = 0;
        while (i < statementList.length) {
          node = statementList[i].node;
          nodeType = node.type;
          line = node.loc.start.line;
          range = node.range;
          pos = node.range[1];
          if (node.hasOwnProperty("body")) {
            pos = node.body.range[0] + 1;
          } else if (node.hasOwnProperty("block")) {
            pos = node.block.range[0] + 1;
          }
          if (typeof traceName === "function") {
            signature = traceName.call(null, {
              line: line,
              range: range
            });
          } else {
            puts(inspect(node, null, 10));
            messagesString = readableNode(node);
            signature = traceName + "({ ";
            signature += "lineNumber: " + line + ", ";
            signature += "range: [" + range[0] + ", " + range[1] + "], ";
            signature += "type: '" + nodeType + "', ";
            signature += "messages: " + messagesString + " ";
            signature += "});";
          }
          signature = " " + signature + "";
          fragments.push({
            index: pos,
            text: signature
          });
          i += 1;
        }
        return fragments;
      };
    }
  };

  Tracer = (function() {
    function Tracer(options) {
      if (options == null) {
        options = {};
      }
      this.trace = __bind(this.trace, this);
      this.step_count = 0;
      this.onMessages = function() {};
    }

    Tracer.prototype.trace = function(opts) {
      var _this = this;
      this.step_count = 0;
      return function(info) {
        var error;
        _this.step_count = _this.step_count + 1;
        if (_this.step_count >= opts.count) {
          _this.onMessages(info.messages);
          error = new Error(Choc.PAUSE_ERROR_NAME);
          error.info = info;
          throw error;
        }
      };
    };

    return Tracer;

  })();

  generateScrubbedSource = function(source, count) {
    var modifiers, morphed;
    modifiers = [tracers.postStatement(Choc.TRACE_FUNCTION_NAME)];
    morphed = esmorph.modify(source, modifiers);
    return morphed;
  };

  noop = function() {};

  scrub = function(source, count, opts) {
    var afterAll, afterEach, beforeEach, e, locals, localsStr, newSource, notify, onMessages, tracer, __choc_trace;
    notify = opts.notify || noop;
    beforeEach = opts.beforeEach || noop;
    afterEach = opts.afterEach || noop;
    afterAll = opts.afterAll || noop;
    onMessages = opts.onMessages || noop;
    locals = opts.locals || [];
    newSource = generateScrubbedSource(source, count);
    puts(newSource);
    locals.Choc = Choc;
    localsStr = _.map(_.keys(locals), function(name) {
      return "var " + name + " = locals." + name + ";";
    }).join("; ");
    try {
      beforeEach();
      tracer = new Tracer();
      tracer.onMessages = onMessages;
      __choc_trace = tracer.trace({
        count: count
      });
      eval(localsStr + "\n" + newSource);
      console.log(tracer.step_count);
      return afterAll({
        step_count: tracer.step_count
      });
    } catch (_error) {
      e = _error;
      if (e.message === Choc.PAUSE_ERROR_NAME) {
        return notify(e.info);
      } else {
        throw e;
      }
    } finally {
      afterEach();
    }
  };

  if ((typeof require !== "undefined" && require !== null) && (require.main === module)) {
    source_todo = "function add(a, b) {\n  var c = 3;\n  return a + b;\n}\n\nvar sub = function(a, b) {\n  var c = 3;\n  return a - b;\n}\nwhile (shift <= 200) {\n  // console.log(shift);\n  var x = add(1, shift);\n  shift += 14; // increment\n}";
    source = "// Life, Universe, and Everything\nvar answer = 6 * 7, question = 3;\nvar foo = \"bar\";\nconsole.log(answer); console.log(foo);\n\n// parabolas\nvar shift = 0;\nwhile (shift <= 200) {\n  // console.log(shift);\n  shift += 14; // increment\n}";
    scrubNotify = function(info) {
      return puts(inspect(info));
    };
    scrub(source, 10, {
      notify: scrubNotify
    });
  }

  exports.scrub = scrub;

  todo = "* parse only once\n* function returns - i think we're going to need to transform every ReturnStatement to hoist its argument into a variable - then give the language for that variable and pause on that line right before you return it\n* function calls on the line - ";

}).call(this);
