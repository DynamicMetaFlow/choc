// Generated by CoffeeScript 1.6.3
(function() {
  var Choc, Tracer, collectStatements, escodegen, esmorph, esprima, generateScrubbedSource, inspect, isStatement, noop, puts, scrub, scrubNotify, source, todo, tracers, traverse, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  _ = require("underscore");

  Choc = {
    VERSION: "0.0.1",
    TRACE_FUNCTION_NAME: "__choc_trace",
    PAUSE_ERROR_NAME: "__choc_pause",
    EXECUTION_FINISHED_ERROR_NAME: "__choc_finished"
  };

  isStatement = function(thing) {
    var statements;
    statements = ['BreakStatement', 'ContinueStatement', 'DoWhileStatement', 'DebuggerStatement', 'EmptyStatement', 'ExpressionStatement', 'ForStatement', 'ForInStatement', 'IfStatement', 'LabeledStatement', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'WhileStatement', 'WithStatement', 'VariableDeclaration'];
    return _.contains(statements, thing);
  };

  traverse = function(object, visitor, path) {
    var child, key, _results;
    key = void 0;
    child = void 0;
    if (typeof path === "undefined") {
      path = [];
    }
    visitor.call(null, object, path);
    _results = [];
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        child = object[key];
        if (typeof child === "object" && child !== null) {
          _results.push(traverse(child, visitor, [object].concat(path)));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  collectStatements = function(code, tree) {
    var statements;
    statements = [];
    traverse(tree, function(node, path) {
      if (isStatement(node.type)) {
        return statements.push({
          node: node,
          path: path
        });
      }
    });
    return statements;
  };

  tracers = {
    postStatement: function(traceName) {
      return function(code) {
        var fragments, i, line, node, nodeType, pos, range, signature, statementList, tree;
        tree = esprima.parse(code, {
          range: true,
          loc: true
        });
        statementList = collectStatements(code, tree);
        fragments = [];
        i = 0;
        while (i < statementList.length) {
          node = statementList[i].node;
          nodeType = node.type;
          line = node.loc.start.line;
          range = node.range;
          pos = node.range[1];
          if (node.hasOwnProperty("body")) {
            pos = node.body.range[0] + 1;
          } else if (node.hasOwnProperty("block")) {
            pos = node.block.range[0] + 1;
          }
          if (typeof traceName === "function") {
            signature = traceName.call(null, {
              line: line,
              range: range
            });
          } else {
            signature = traceName + "({ ";
            signature += "lineNumber: " + line + ", ";
            signature += "range: [" + range[0] + ", " + range[1] + "], ";
            signature += "type: '" + nodeType + "' ";
            signature += "});";
          }
          signature = " " + signature + "";
          fragments.push({
            index: pos,
            text: signature
          });
          i += 1;
        }
        return fragments;
      };
    }
  };

  Tracer = (function() {
    function Tracer(options) {
      if (options == null) {
        options = {};
      }
      this.trace = __bind(this.trace, this);
      this.step_count = 0;
    }

    Tracer.prototype.trace = function(opts) {
      var _this = this;
      this.step_count = 0;
      return function(info) {
        var error;
        _this.step_count = _this.step_count + 1;
        if (_this.step_count >= opts.count) {
          error = new Error(Choc.PAUSE_ERROR_NAME);
          error.info = info;
          throw error;
        }
      };
    };

    return Tracer;

  })();

  generateScrubbedSource = function(source, count) {
    var modifiers, morphed;
    modifiers = [tracers.postStatement(Choc.TRACE_FUNCTION_NAME)];
    morphed = esmorph.modify(source, modifiers);
    return morphed;
  };

  noop = function() {};

  scrub = function(source, count, opts) {
    var afterEach, beforeEach, e, locals, localsStr, newSource, notify, tracer, __choc_trace;
    notify = opts.notify || noop;
    beforeEach = opts.beforeEach || noop;
    afterEach = opts.afterEach || noop;
    locals = opts.locals || [];
    newSource = generateScrubbedSource(source, count);
    locals.Choc = Choc;
    localsStr = _.map(_.keys(locals), function(name) {
      return "var " + name + " = locals." + name + ";";
    }).join("; ");
    try {
      beforeEach();
      tracer = new Tracer();
      __choc_trace = tracer.trace({
        count: count
      });
      eval(localsStr + "\n" + newSource);
      return console.log(tracer.step_count);
    } catch (_error) {
      e = _error;
      if (e.message === Choc.PAUSE_ERROR_NAME) {
        return notify(e.info);
      } else {
        throw e;
      }
    } finally {
      afterEach();
    }
  };

  if ((typeof require !== "undefined" && require !== null) && (require.main === module)) {
    source = "// Life, Universe, and Everything\nvar answer = 6 * 7;\nvar foo = \"bar\";\nconsole.log(answer); console.log(foo);\n\n// parabolas\nvar shift = 0;\nwhile (shift <= 200) {\n  // console.log(shift);\n  shift += 14; // increment\n}";
    scrubNotify = function(info) {
      return puts(inspect(info));
    };
    scrub(source, 10, {
      notify: scrubNotify
    });
  }

  exports.scrub = scrub;

  todo = "* highlight current line\n* parse only once";

}).call(this);
