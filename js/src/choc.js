// Generated by CoffeeScript 1.6.3
(function() {
  var ALL_STATEMENTS, Choc, HOIST_STATEMENTS, PLAIN_STATEMENTS, Tracer, debug, deep, escodegen, esmorph, esprima, estraverse, generateAnnotatedSource, generateAnnotatedSourceM, generateStatement, generateVariableAssignment, generateVariableDeclaration, inspect, isHoistStatement, isPlainStatement, isStatement, noop, pp, puts, readable, scrub, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  pp = function(x) {
    return puts(inspect(x, null, 1000));
  };

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  estraverse = require('../../lib/estraverse');

  _ = require("underscore");

  readable = require("./readable");

  debug = require("debug")("choc");

  deep = require("deep");

  Choc = {
    VERSION: "0.0.1",
    TRACE_FUNCTION_NAME: "__choc_trace",
    PAUSE_ERROR_NAME: "__choc_pause",
    EXECUTION_FINISHED_ERROR_NAME: "__choc_finished"
  };

  PLAIN_STATEMENTS = ['BreakStatement', 'ContinueStatement', 'DoWhileStatement', 'DebuggerStatement', 'EmptyStatement', 'ExpressionStatement', 'ForStatement', 'ForInStatement', 'LabeledStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'WithStatement', 'VariableDeclaration'];

  HOIST_STATEMENTS = ['ReturnStatement', 'WhileStatement', 'IfStatement'];

  ALL_STATEMENTS = PLAIN_STATEMENTS.concat(HOIST_STATEMENTS);

  isStatement = function(nodeType) {
    return _.contains(ALL_STATEMENTS, nodeType);
  };

  isPlainStatement = function(nodeType) {
    return _.contains(PLAIN_STATEMENTS, nodeType);
  };

  isHoistStatement = function(nodeType) {
    return _.contains(HOIST_STATEMENTS, nodeType);
  };

  generateVariableDeclaration = function(varInit) {
    var identifier;
    identifier = "__choc_var_" + Math.floor(Math.random() * 1000000);
    return {
      type: 'VariableDeclaration',
      kind: 'var',
      declarations: [
        {
          type: 'VariableDeclarator',
          id: {
            type: 'Identifier',
            name: identifier
          },
          init: varInit
        }
      ]
    };
  };

  generateVariableAssignment = function(identifier, valueNode) {
    return {
      type: 'ExpressionStatement',
      expression: {
        type: 'AssignmentExpression',
        operator: '=',
        left: {
          type: 'Identifier',
          name: identifier
        },
        right: valueNode
      }
    };
  };

  generateStatement = function(code) {
    return esprima.parse(code).body[0];
  };

  generateAnnotatedSource = function(source) {
    var candidate, candidates, e, element, error, hoister, innerBlockContainer, line, messagesString, newAssignmentNode, newCodeTree, newPosition, newVariableName, node, nodeType, originalExpression, parent, parentPathAttribute, parentPathIndex, pos, range, signature, traceTree, tree, _i, _len;
    try {
      tree = esprima.parse(source, {
        range: true,
        loc: true
      });
    } catch (_error) {
      e = _error;
      error = new Error("choc source parsing error");
      error.original = e;
      throw error;
    }
    candidates = [];
    estraverse.traverse(tree, {
      enter: function(node, parent, element) {
        if (isStatement(node.type)) {
          return candidates.push({
            node: node,
            parent: parent,
            element: element
          });
        }
      }
    });
    hoister = {
      'IfStatement': 'test',
      'WhileStatement': 'test',
      'ReturnStatement': 'argument'
    };
    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
      candidate = candidates[_i];
      node = candidate.node;
      parent = candidate.parent;
      element = candidate.element;
      parentPathAttribute = element.path[0];
      parentPathIndex = element.path[1];
      if (!parent.hasOwnProperty("__choc_offset")) {
        parent.__choc_offset = 0;
      }
      nodeType = node.type;
      line = node.loc.start.line;
      range = node.range;
      pos = node.range[1];
      messagesString = readable.readableNode(node);
      if (isStatement(nodeType)) {
        signature = "" + Choc.TRACE_FUNCTION_NAME + "({ lineNumber: " + line + ", range: [ " + range[0] + ", " + range[1] + " ], type: '" + nodeType + "', messages: " + messagesString + " });";
        traceTree = esprima.parse(signature).body[0];
        newPosition = null;
        if (isHoistStatement(nodeType)) {
          originalExpression = node[hoister[nodeType]];
          newCodeTree = generateVariableDeclaration(originalExpression);
          parent[parentPathAttribute].splice(parentPathIndex + parent.__choc_offset, 0, newCodeTree);
          newVariableName = newCodeTree.declarations[0].id.name;
          node[hoister[node.type]] = {
            type: 'Identifier',
            name: newVariableName
          };
          parent.__choc_offset = parent.__choc_offset + 1;
          if (_.isNumber(parentPathIndex)) {
            newPosition = parentPathIndex + parent.__choc_offset;
            parent[parentPathAttribute].splice(newPosition, 0, traceTree);
            parent.__choc_offset = parent.__choc_offset + 1;
          } else {
            puts("WARNING: no parent idx");
          }
          if (nodeType === "WhileStatement") {
            newAssignmentNode = generateVariableAssignment(newVariableName, originalExpression);
            innerBlockContainer = node.body.body;
            innerBlockContainer.push(newAssignmentNode);
            innerBlockContainer.push(traceTree);
          }
        } else if (isPlainStatement(nodeType)) {
          if (_.isNumber(parentPathIndex)) {
            newPosition = parentPathIndex + parent.__choc_offset + 1;
            parent[parentPathAttribute].splice(newPosition, 0, traceTree);
            parent.__choc_offset = parent.__choc_offset + 1;
          } else {
            puts("WARNING: no parent idx");
          }
        }
      }
    }
    return escodegen.generate(tree, {
      format: {
        compact: false
      }
    });
  };

  generateAnnotatedSourceM = _.memoize(generateAnnotatedSource);

  Tracer = (function() {
    function Tracer(options) {
      if (options == null) {
        options = {};
      }
      this.trace = __bind(this.trace, this);
      this.frameCount = 0;
      this.onMessages = function() {};
      this.clearTimeline();
    }

    Tracer.prototype.clearTimeline = function() {
      return this.timeline = {
        steps: [],
        stepMap: {},
        maxLines: 0
      };
    };

    Tracer.prototype.trace = function(opts) {
      var _this = this;
      this.frameCount = 0;
      return function(info) {
        var error, _base, _name;
        _this.timeline.steps[_this.frameCount] = {
          lineNumber: info.lineNumber
        };
        (_base = _this.timeline.stepMap)[_name = _this.frameCount] || (_base[_name] = {});
        _this.timeline.stepMap[_this.frameCount][info.lineNumber - 1] = true;
        _this.timeline.maxLines = Math.max(_this.timeline.maxLines, info.lineNumber);
        info.frameNumber = _this.frameCount;
        _this.frameCount = _this.frameCount + 1;
        if (_this.frameCount >= opts.count) {
          _this.onMessages(info.messages);
          error = new Error(Choc.PAUSE_ERROR_NAME);
          error.info = info;
          throw error;
        }
      };
    };

    return Tracer;

  })();

  noop = function() {};

  scrub = function(source, count, opts) {
    var afterAll, afterEach, beforeEach, e, executionTerminated, locals, localsStr, newSource, onCodeError, onFrame, onMessages, onTimeline, tracer, __choc_first_message, __choc_trace;
    onFrame = opts.onFrame || noop;
    beforeEach = opts.beforeEach || noop;
    afterEach = opts.afterEach || noop;
    afterAll = opts.afterAll || noop;
    onTimeline = opts.onTimeline || noop;
    onMessages = opts.onMessages || noop;
    onCodeError = opts.onCodeError || noop;
    locals = opts.locals || {};
    newSource = generateAnnotatedSource(source);
    debug(newSource);
    tracer = new Tracer();
    tracer.onMessages = onMessages;
    tracer.onTimeline = onTimeline;
    executionTerminated = false;
    try {
      beforeEach();
      __choc_trace = tracer.trace({
        count: count
      });
      __choc_first_message = function(messages) {
        var _ref1;
        return ((_ref1 = messages[0]) != null ? _ref1.message : void 0) || "TODO";
      };
      locals.Choc = Choc;
      localsStr = _.map(_.keys(locals), function(name) {
        return "var " + name + " = locals." + name + ";";
      }).join("; ");
      eval(localsStr + "\n" + newSource);
      executionTerminated = true;
      return console.log("execution terminated");
    } catch (_error) {
      e = _error;
      if (e.message === Choc.PAUSE_ERROR_NAME) {
        return onFrame(e.info);
      } else {
        throw e;
      }
    } finally {
      afterEach();
      if (executionTerminated) {
        afterAll({
          frameCount: tracer.frameCount
        });
        onTimeline(tracer.timeline);
      }
    }
  };

  exports.scrub = scrub;

  exports.generateAnnotatedSource = generateAnnotatedSource;

}).call(this);
