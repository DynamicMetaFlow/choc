// Generated by CoffeeScript 1.6.3
(function() {
  var collectStatements, escodegen, esmorph, esprima, inspect, isStatement, preamble, puts, scrub, tracers, traverse, _, _ref;

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  _ = require("underscore");

  isStatement = function(thing) {
    var statements;
    statements = ['BreakStatement', 'ContinueStatement', 'DoWhileStatement', 'DebuggerStatement', 'EmptyStatement', 'ExpressionStatement', 'ForStatement', 'ForInStatement', 'IfStatement', 'LabeledStatement', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'WhileStatement', 'WithStatement', 'VariableDeclaration'];
    return _.contains(statements, thing);
  };

  traverse = function(object, visitor, path) {
    var child, key, _results;
    key = void 0;
    child = void 0;
    if (typeof path === "undefined") {
      path = [];
    }
    visitor.call(null, object, path);
    _results = [];
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        child = object[key];
        if (typeof child === "object" && child !== null) {
          _results.push(traverse(child, visitor, [object].concat(path)));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  collectStatements = function(code, tree) {
    var statements;
    statements = [];
    traverse(tree, function(node, path) {
      if (isStatement(node.type)) {
        return statements.push({
          node: node,
          path: path
        });
      }
    });
    return statements;
  };

  tracers = {
    postStatement: function(traceName) {
      return function(code) {
        var fragments, i, line, node, nodeType, pos, range, signature, statementList, tree;
        tree = esprima.parse(code, {
          range: true,
          loc: true
        });
        statementList = collectStatements(code, tree);
        fragments = [];
        i = 0;
        while (i < statementList.length) {
          node = statementList[i].node;
          nodeType = node.type;
          line = node.loc.start.line;
          range = node.range;
          pos = node.range[1];
          if (node.hasOwnProperty("body")) {
            pos = node.body.range[0] + 1;
          } else if (node.hasOwnProperty("block")) {
            pos = node.block.range[0] + 1;
          }
          if (typeof traceName === "function") {
            signature = traceName.call(null, {
              line: line,
              range: range
            });
          } else {
            signature = traceName + "({ ";
            signature += "lineNumber: " + line + ", ";
            signature += "range: [" + range[0] + ", " + range[1] + "], ";
            signature += "type: '" + nodeType + "' ";
            signature += "});";
          }
          signature = " " + signature + "";
          fragments.push({
            index: pos,
            text: signature
          });
          i += 1;
        }
        return fragments;
      };
    }
  };

  preamble = {
    trace: function(opts) {
      var __choc_count,
        _this = this;
      __choc_count = 0;
      return function(info) {
        __choc_count = __choc_count + 1;
        console.log("count:  " + __choc_count + "/" + opts.count + " type: " + info.type);
        if (__choc_count >= opts.count) {
          throw new Error("__choc_pause");
        }
      };
    }
  };

  scrub = function(source, count) {
    var chocified, modifiers, morphed;
    modifiers = [tracers.postStatement("__choc_trace")];
    morphed = esmorph.modify(source, modifiers);
    chocified = "__choc_trace = (" + (preamble.trace.toString()) + ")({count: " + count + "})\n" + morphed;
    return chocified;
  };

  exports.scrub = scrub;

}).call(this);
