// Generated by CoffeeScript 1.6.3
(function() {
  var Choc, Tracer, collectStatements, escodegen, esmorph, esprima, generateReadableExpression, generateReadableStatement, generateScrubbedSource, inspect, isStatement, noop, puts, readableNode, scrub, scrubNotify, source, source_todo, todo, tracers, traverse, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  _ = require("underscore");

  Choc = {
    VERSION: "0.0.1",
    TRACE_FUNCTION_NAME: "__choc_trace",
    PAUSE_ERROR_NAME: "__choc_pause",
    EXECUTION_FINISHED_ERROR_NAME: "__choc_finished"
  };

  isStatement = function(thing) {
    var statements;
    statements = ['BreakStatement', 'ContinueStatement', 'DoWhileStatement', 'DebuggerStatement', 'EmptyStatement', 'ExpressionStatement', 'ForStatement', 'ForInStatement', 'IfStatement', 'LabeledStatement', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'WhileStatement', 'WithStatement', 'VariableDeclaration'];
    return _.contains(statements, thing);
  };

  traverse = function(object, visitor, path) {
    var child, key, _results;
    key = void 0;
    child = void 0;
    if (typeof path === "undefined") {
      path = [];
    }
    visitor.call(null, object, path);
    _results = [];
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        child = object[key];
        if (typeof child === "object" && child !== null) {
          _results.push(traverse(child, visitor, [object].concat(path)));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  collectStatements = function(code, tree) {
    var statements;
    statements = [];
    traverse(tree, function(node, path) {
      if (isStatement(node.type)) {
        return statements.push({
          node: node,
          path: path
        });
      }
    });
    return statements;
  };

  generateReadableExpression = function(node) {
    var message, operators;
    switch (node.type) {
      case 'AssignmentExpression':
        operators = {
          "=": "'set " + node.left.name + " to ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ")",
          "+=": "'add ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' to " + node.left.name + " and set " + node.left.name + " to ' + " + node.left.name,
          "-=": "'subtract ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' from " + node.left.name + "'",
          "*=": "'multiply " + node.left.name + " by ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") ",
          "/=": "'divide " + node.left.name + " by ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") ",
          "%=": "'divide " + node.left.name + " by ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' and set " + node.left.name + " to the remainder'"
        };
        message = operators[node.operator] || "";
        return "[ { lineNumber: " + node.loc.start.line + ", message: " + message + " }]";
      case 'BinaryExpression':
        operators = {
          "==": "''",
          "!=": "''",
          "===": "''",
          "!==": "''",
          "<": "''",
          "<=": "''",
          ">": "''",
          ">=": "''",
          "<<": "''",
          ">>": "''",
          ">>>": "''",
          "+": "'add ' + __choc_first_message(" + (generateReadableExpression(node.right)) + ") + ' to " + node.left.name + " and set " + node.left.name + " to ' + " + node.left.name,
          "-": "''",
          "*": "''",
          "/": "''",
          "%": "''",
          "|": "''",
          "^": "''",
          "in": "''",
          "instanceof": "''",
          "..": "''"
        };
        message = operators[node.operator] || "";
        return "[ { lineNumber: " + node.loc.start.line + ", message: " + message + " }]";
      case 'Literal':
        return "[ { lineNumber: " + node.loc.start.line + ", message: '" + node.value + "' }]";
      default:
        return "[]";
    }
  };

  generateReadableStatement = function(node) {
    var i, msgs, sentences;
    switch (node.type) {
      case 'VariableDeclaration':
        i = 0;
        sentences = _.map(node.declarations, function(dec) {
          var name, prefix;
          name = dec.id.name;
          prefix = i === 0 ? "Create" : " and create";
          i = i + 1;
          return "'" + prefix + " the variable <span class=\"choc-variable\">" + name + "</span> and set it to <span class=\"choc-value\">' + " + name + " + '</span>'";
        });
        msgs = _.map(sentences, function(sentence) {
          var s;
          s = "{ ";
          s += "lineNumber: " + node.loc.start.line + ", ";
          s += "message: " + sentence;
          return s += " }";
        });
        return "[ " + msgs.join(", ") + " ]";
      case 'ExpressionStatement':
        return generateReadableExpression(node.expression);
      default:
        return "[]";
    }
  };

  readableNode = function(node) {
    switch (node.type) {
      case 'VariableDeclaration':
      case 'ExpressionStatement':
        return generateReadableStatement(node);
      case 'AssignmentExpression':
        return generateReadableExpression;
      default:
        return "[]";
    }
  };

  tracers = {
    postStatement: function(traceName) {
      return function(code) {
        var fragments, i, line, messagesString, node, nodeType, pos, range, signature, statementList, tree;
        tree = esprima.parse(code, {
          range: true,
          loc: true
        });
        statementList = collectStatements(code, tree);
        fragments = [];
        i = 0;
        while (i < statementList.length) {
          node = statementList[i].node;
          nodeType = node.type;
          line = node.loc.start.line;
          range = node.range;
          pos = node.range[1];
          if (node.hasOwnProperty("body")) {
            pos = node.body.range[0] + 1;
          } else if (node.hasOwnProperty("block")) {
            pos = node.block.range[0] + 1;
          }
          if (typeof traceName === "function") {
            signature = traceName.call(null, {
              line: line,
              range: range
            });
          } else {
            puts(inspect(node, null, 10));
            messagesString = readableNode(node);
            signature = traceName + "({ ";
            signature += "lineNumber: " + line + ", ";
            signature += "range: [" + range[0] + ", " + range[1] + "], ";
            signature += "type: '" + nodeType + "', ";
            signature += "messages: " + messagesString + " ";
            signature += "});";
          }
          signature = " " + signature + "";
          fragments.push({
            index: pos,
            text: signature
          });
          i += 1;
        }
        return fragments;
      };
    }
  };

  Tracer = (function() {
    function Tracer(options) {
      if (options == null) {
        options = {};
      }
      this.trace = __bind(this.trace, this);
      this.step_count = 0;
      this.onMessages = function() {};
      this.clearTimeline();
    }

    Tracer.prototype.clearTimeline = function() {
      return this.timeline = {
        steps: [],
        maxLines: 0
      };
    };

    Tracer.prototype.trace = function(opts) {
      var _this = this;
      this.step_count = 0;
      return function(info) {
        var error;
        _this.timeline.steps[_this.step_count] = {
          lineNumber: info.lineNumber
        };
        _this.timeline.maxLines = Math.max(_this.timeline.maxLines, info.lineNumber);
        _this.step_count = _this.step_count + 1;
        if (_this.step_count >= opts.count) {
          _this.onMessages(info.messages);
          error = new Error(Choc.PAUSE_ERROR_NAME);
          error.info = info;
          throw error;
        }
      };
    };

    return Tracer;

  })();

  generateScrubbedSource = function(source, count) {
    var modifiers, morphed;
    modifiers = [tracers.postStatement(Choc.TRACE_FUNCTION_NAME)];
    morphed = esmorph.modify(source, modifiers);
    return morphed;
  };

  noop = function() {};

  scrub = function(source, count, opts) {
    var afterAll, afterEach, beforeEach, e, locals, localsStr, newSource, notify, onMessages, onTimeline, tracer, __choc_first_message, __choc_trace;
    notify = opts.notify || noop;
    beforeEach = opts.beforeEach || noop;
    afterEach = opts.afterEach || noop;
    afterAll = opts.afterAll || noop;
    onTimeline = opts.onTimeline || noop;
    onMessages = opts.onMessages || noop;
    locals = opts.locals || [];
    newSource = generateScrubbedSource(source, count);
    puts(newSource);
    locals.Choc = Choc;
    localsStr = _.map(_.keys(locals), function(name) {
      return "var " + name + " = locals." + name + ";";
    }).join("; ");
    try {
      beforeEach();
      tracer = new Tracer();
      tracer.onMessages = onMessages;
      tracer.onTimeline = onTimeline;
      __choc_trace = tracer.trace({
        count: count
      });
      __choc_first_message = function(messages) {
        var _ref1;
        return ((_ref1 = messages[0]) != null ? _ref1.message : void 0) || "TODO";
      };
      eval(localsStr + "\n" + newSource);
      console.log(tracer.step_count);
      afterAll({
        step_count: tracer.step_count
      });
      return onTimeline(tracer.timeline);
    } catch (_error) {
      e = _error;
      if (e.message === Choc.PAUSE_ERROR_NAME) {
        return notify(e.info);
      } else {
        throw e;
      }
    } finally {
      afterEach();
    }
  };

  if ((typeof require !== "undefined" && require !== null) && (require.main === module)) {
    source_todo = "function add(a, b) {\n  var c = 3;\n  return a + b;\n}\n\nvar sub = function(a, b) {\n  var c = 3;\n  return a - b;\n}\nwhile (shift <= 200) {\n  // console.log(shift);\n  var x = add(1, shift);\n  shift += 14; // increment\n}";
    source = "// Life, Universe, and Everything\nvar answer = 6 * 7, question = 3;\nvar foo = \"bar\";\nconsole.log(answer); console.log(foo);\n\n// parabolas\nvar shift = 0;\nwhile (shift <= 200) {\n  // console.log(shift);\n  var foo = shift;\n  foo = shift - 1;\n  shift += 14; // increment\n}";
    scrubNotify = function(info) {
      return puts(inspect(info));
    };
    scrub(source, 10, {
      notify: scrubNotify
    });
  }

  exports.scrub = scrub;

  todo = "* parse only once\n* function returns - i think we're going to need to transform every ReturnStatement to hoist its argument into a variable - then give the language for that variable and pause on that line right before you return it\n* function calls on the line - ";

}).call(this);
