// Generated by CoffeeScript 1.6.3
(function() {
  var ALL_STATEMENTS, Choc, HOIST_STATEMENTS, PLAIN_STATEMENTS, Tracer, collectNodes, collectStatements, debug, deep, escodegen, esmorph, esprima, estraverse, generateAnnotatedSource, generateAnnotatedSource2, generateAnnotatedSourceM, generateVariableDeclaration, hoist, inspect, isHoistStatement, isPlainStatement, isStatement, noop, pp, puts, readable, scrub, statementAnnotator, traverse, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  pp = function(x) {
    return puts(inspect(x, null, 1000));
  };

  esprima = require("esprima");

  escodegen = require("escodegen");

  esmorph = require("esmorph");

  estraverse = require('../../lib/estraverse');

  _ = require("underscore");

  readable = require("./readable");

  debug = require("debug")("choc");

  deep = require("deep");

  Choc = {
    VERSION: "0.0.1",
    TRACE_FUNCTION_NAME: "__choc_trace",
    PAUSE_ERROR_NAME: "__choc_pause",
    EXECUTION_FINISHED_ERROR_NAME: "__choc_finished"
  };

  PLAIN_STATEMENTS = ['BreakStatement', 'ContinueStatement', 'DoWhileStatement', 'DebuggerStatement', 'EmptyStatement', 'ExpressionStatement', 'ForStatement', 'ForInStatement', 'LabeledStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'WithStatement', 'VariableDeclaration'];

  HOIST_STATEMENTS = ['ReturnStatement', 'WhileStatement', 'IfStatement'];

  ALL_STATEMENTS = PLAIN_STATEMENTS.concat(HOIST_STATEMENTS);

  isStatement = function(nodeType) {
    return _.contains(ALL_STATEMENTS, nodeType);
  };

  isPlainStatement = function(nodeType) {
    return _.contains(PLAIN_STATEMENTS, nodeType);
  };

  isHoistStatement = function(nodeType) {
    return _.contains(HOIST_STATEMENTS, nodeType);
  };

  traverse = function(object, visitor, path) {
    var child, key, _results;
    key = void 0;
    child = void 0;
    if (typeof path === "undefined") {
      path = [];
    }
    visitor.call(null, object, path);
    _results = [];
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        child = object[key];
        if (typeof child === "object" && child !== null) {
          _results.push(traverse(child, visitor, [object].concat(path)));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  collectNodes = function(tree, condition) {
    var nodes;
    nodes = [];
    traverse(tree, function(node, path) {
      if (condition(node, path)) {
        return nodes.push({
          node: node,
          path: path
        });
      }
    });
    return nodes;
  };

  collectStatements = function(tree) {
    return collectNodes(tree, function(node, path) {
      return isStatement(node.type);
    });
  };

  statementAnnotator = function(traceName) {
    return function(code) {
      var fragments, i, line, messagesString, node, nodeType, pos, range, signature, statementList, tree;
      tree = esprima.parse(code, {
        range: true,
        loc: true
      });
      statementList = collectStatements(tree);
      fragments = [];
      i = 0;
      while (i < statementList.length) {
        node = statementList[i].node;
        nodeType = node.type;
        line = node.loc.start.line;
        range = node.range;
        pos = node.range[1];
        if (node.hasOwnProperty("body")) {
          pos = node.body.range[0] + 1;
        } else if (node.hasOwnProperty("block")) {
          pos = node.block.range[0] + 1;
        }
        messagesString = readable.readableNode(node);
        signature = "" + traceName + "({ lineNumber: " + line + ", range: [ " + range[0] + ", " + range[1] + " ], type: '" + nodeType + "', messages: " + messagesString + " });";
        fragments.push({
          index: pos,
          text: " " + signature
        });
        i += 1;
      }
      return fragments;
    };
  };

  generateVariableDeclaration = function(varInit) {
    var identifier;
    identifier = "__choc_var_" + Math.floor(Math.random() * 1000000);
    return {
      type: 'VariableDeclaration',
      kind: 'var',
      declarations: [
        {
          type: 'VariableDeclarator',
          id: {
            type: 'Identifier',
            name: identifier
          },
          init: varInit
        }
      ]
    };
  };

  hoist = function(source) {
    var candidate, candidates, hoister, newCodeTree, newVariableName, node, originalExpression, parent, tree, _i, _len;
    tree = esprima.parse(source, {
      range: true,
      loc: true
    });
    candidates = [];
    estraverse.traverse(tree, {
      enter: function(node, parent) {
        switch (node.type) {
          case 'IfStatement':
          case 'WhileStatement':
          case 'ReturnStatement':
            return candidates.push({
              node: node,
              parent: parent
            });
          default:
            return true;
        }
      }
    });
    hoister = {
      'IfStatement': 'test',
      'WhileStatement': 'test',
      'ReturnStatement': 'argument'
    };
    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
      candidate = candidates[_i];
      node = candidate.node;
      parent = candidate.parent;
      switch (node.type) {
        case 'IfStatement':
        case 'WhileStatement':
        case 'ReturnStatement':
          originalExpression = node[hoister[node.type]];
          newCodeTree = generateVariableDeclaration(originalExpression);
          parent[node._parentAttribute].splice(node._parentAttributeIdx, 0, newCodeTree);
          newVariableName = newCodeTree.declarations[0].id.name;
          node[hoister[node.type]] = {
            type: 'Identifier',
            name: newVariableName
          };
          break;
        default:
          true;
      }
    }
    return escodegen.generate(tree);
  };

  generateAnnotatedSource2 = function(source) {
    var candidate, candidates, element, hoister, line, messagesString, newCodeTree, newPosition, newVariableName, node, nodeType, originalExpression, parent, parentPathAttribute, parentPathIndex, pos, range, signature, traceTree, tree, _i, _len;
    tree = esprima.parse(source, {
      range: true,
      loc: true
    });
    candidates = [];
    estraverse.traverse(tree, {
      enter: function(node, parent, element) {
        if (isStatement(node.type)) {
          return candidates.push({
            node: node,
            parent: parent,
            element: element
          });
        }
      }
    });
    hoister = {
      'IfStatement': 'test',
      'WhileStatement': 'test',
      'ReturnStatement': 'argument'
    };
    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
      candidate = candidates[_i];
      node = candidate.node;
      parent = candidate.parent;
      element = candidate.element;
      parentPathAttribute = element.path[0];
      parentPathIndex = element.path[1];
      if (!parent.hasOwnProperty("__choc_offset")) {
        parent.__choc_offset = 0;
      }
      nodeType = node.type;
      line = node.loc.start.line;
      range = node.range;
      pos = node.range[1];
      messagesString = readable.readableNode(node);
      if (isStatement(nodeType)) {
        signature = "" + Choc.TRACE_FUNCTION_NAME + "({ lineNumber: " + line + ", range: [ " + range[0] + ", " + range[1] + " ], type: '" + nodeType + "', messages: " + messagesString + " });";
        traceTree = esprima.parse(signature).body[0];
        newPosition = null;
        if (isHoistStatement(nodeType)) {
          originalExpression = node[hoister[nodeType]];
          newCodeTree = generateVariableDeclaration(originalExpression);
          parent[parentPathAttribute].splice(parentPathIndex + parent.__choc_offset, 0, newCodeTree);
          newVariableName = newCodeTree.declarations[0].id.name;
          node[hoister[node.type]] = {
            type: 'Identifier',
            name: newVariableName
          };
          parent.__choc_offset = parent.__choc_offset + 1;
          if (_.isNumber(parentPathIndex)) {
            newPosition = parentPathIndex + parent.__choc_offset;
          } else {
            puts("WARNING: no parent idx");
          }
        }
        if (isPlainStatement(nodeType)) {
          if (_.isNumber(parentPathIndex)) {
            newPosition = parentPathIndex + parent.__choc_offset + 1;
          } else {
            puts("WARNING: no parent idx");
          }
        }
        parent[parentPathAttribute].splice(newPosition, 0, traceTree);
        parent.__choc_offset = parent.__choc_offset + 1;
      }
    }
    return escodegen.generate(tree, {
      format: {
        compact: false
      }
    });
  };

  generateAnnotatedSource = function(source) {
    var modifiers, morphed;
    modifiers = [statementAnnotator(Choc.TRACE_FUNCTION_NAME)];
    morphed = esmorph.modify(source, modifiers);
    return morphed;
  };

  generateAnnotatedSourceM = _.memoize(generateAnnotatedSource);

  Tracer = (function() {
    function Tracer(options) {
      if (options == null) {
        options = {};
      }
      this.trace = __bind(this.trace, this);
      this.frameCount = 0;
      this.onMessages = function() {};
      this.clearTimeline();
    }

    Tracer.prototype.clearTimeline = function() {
      return this.timeline = {
        steps: [],
        stepMap: {},
        maxLines: 0
      };
    };

    Tracer.prototype.trace = function(opts) {
      var _this = this;
      this.frameCount = 0;
      return function(info) {
        var error, _base, _name;
        _this.timeline.steps[_this.frameCount] = {
          lineNumber: info.lineNumber
        };
        (_base = _this.timeline.stepMap)[_name = _this.frameCount] || (_base[_name] = {});
        _this.timeline.stepMap[_this.frameCount][info.lineNumber - 1] = true;
        _this.timeline.maxLines = Math.max(_this.timeline.maxLines, info.lineNumber);
        info.frameNumber = _this.frameCount;
        _this.frameCount = _this.frameCount + 1;
        if (_this.frameCount >= opts.count) {
          _this.onMessages(info.messages);
          error = new Error(Choc.PAUSE_ERROR_NAME);
          error.info = info;
          throw error;
        }
      };
    };

    return Tracer;

  })();

  noop = function() {};

  scrub = function(source, count, opts) {
    var afterAll, afterEach, beforeEach, e, executionTerminated, locals, localsStr, newSource, onFrame, onMessages, onTimeline, tracer, __choc_first_message, __choc_trace;
    onFrame = opts.onFrame || noop;
    beforeEach = opts.beforeEach || noop;
    afterEach = opts.afterEach || noop;
    afterAll = opts.afterAll || noop;
    onTimeline = opts.onTimeline || noop;
    onMessages = opts.onMessages || noop;
    locals = opts.locals || {};
    newSource = generateAnnotatedSource2(source);
    debug(newSource);
    tracer = new Tracer();
    tracer.onMessages = onMessages;
    tracer.onTimeline = onTimeline;
    executionTerminated = false;
    try {
      beforeEach();
      __choc_trace = tracer.trace({
        count: count
      });
      __choc_first_message = function(messages) {
        var _ref1;
        return ((_ref1 = messages[0]) != null ? _ref1.message : void 0) || "TODO";
      };
      locals.Choc = Choc;
      localsStr = _.map(_.keys(locals), function(name) {
        return "var " + name + " = locals." + name + ";";
      }).join("; ");
      eval(localsStr + "\n" + newSource);
      return executionTerminated = true;
    } catch (_error) {
      e = _error;
      if (e.message === Choc.PAUSE_ERROR_NAME) {
        return onFrame(e.info);
      } else {
        throw e;
      }
    } finally {
      afterEach();
      if (executionTerminated) {
        afterAll({
          frameCount: tracer.frameCount
        });
        onTimeline(tracer.timeline);
      }
    }
  };

  exports.scrub = scrub;

  exports.generateAnnotatedSource = generateAnnotatedSource;

  exports.generateAnnotatedSource = generateAnnotatedSource2;

  exports._hoist = hoist;

}).call(this);
